<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>HTML Template Example</title>
    <!-- Include JSZip library -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>

    <!-- Use the ZAFClient.init() method to create a Zendesk JavaScript API client-->
    <script src="https://static.zdassets.com/zendesk_app_framework_sdk/2.0/zaf_sdk.min.js"></script>
    <script> 
      var client = ZAFClient.init();
      client.invoke('resize', { width: '100%', height: '700px' });
    </script>

    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 800px;
            /*margin: 5px auto;*/
            /*padding: 20px;*/
            line-height: 1.2; /* Reduced from default 1.5 */
        }
        .section-card {
            border: 1px solid #ddd;
            border-radius: 8px;
            padding: 20px;
            margin: 20px 0;
            background-color: #f9f9f9;
            line-height: 1.2; /* Reduced line spacing */
        }
        .field {
            margin: 5px 0; /* Reduced from 10px */
            line-height: 1.1; /* Tight line spacing */
        }
        .label {
            font-weight: bold;
            color: #333;
            line-height: 1.1; /* Tight line spacing */
        }
        .value {
            color: #666;
            margin-left: 10px;
            line-height: 1.1; /* Tight line spacing */
        }
        button {
            background-color: #007bff;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 4px;
            cursor: pointer;
            margin: 5px 5px; /* Reduced from 10px */
            line-height: 1.2; /* Reduced line spacing */
        }
        .small-button {
            background-color: #0d6efd;
            color: white;
            font-size: 0.75em;
            padding: 4px 8px;
            border: none;
            border-radius: 4px;
            margin-left: 1em;
        }
        button:hover {
            background-color: #0056b3;
        }
        .copy-btn {
            background-color: #28a745;
            padding: 5px 10px;
            font-size: 12px;
            margin-left: 10px;
            line-height: 1.1; /* Tight line spacing */
        }
        .copy-btn:hover {
            background-color: #218838;
        }
        .copy-btn.copied {
            background-color: #17a2b8;
        }
        .field {
            display: flex;
            align-items: center;
            margin: 5px 0; /* Reduced from 10px */
            line-height: 1.1; /* Tight line spacing */
        }
        .field-content {
            flex: 1;
            line-height: 1.1; /* Tight line spacing */
        }
    </style>
</head>
<body>
    <!--<h1>Diagnostic Data Reader</h1>-->
    
    <!-- Template container -->
    <div id="template-container"></div>

    <!-- Add Load ZIP button-->
    <div style="text-align: center; margin-top: 1em;">
        <button id="loadZip" style="font-size: 1em; font-weight: bold;">Latest Diagnostic Data</button>
    </div>
    <div id="error-box" style="display:none; color: red; text-align: center; margin-top: 1em;"></div>
   
    <div id="zipContents"></div>
    
    <script>
        window.onerror = function(message, source, lineno, colno, error) {
        console.error('Unhandled Error:', message, 'at', lineno + ':' + colno);
        };

    </script>

    <script>
        //////////////////////////////////////////////////////////////////////////////////////

        // Main function to generate templates for nested data
        function generateNestedHTMLTemplates(nestedData) {
            const templates = {};
            const sections = Object.keys(nestedData);
            sections.forEach(sectionName => {
                const sectionData = nestedData[sectionName];
                const templateId = sectionName.toLowerCase().replace(/\s+/g, '-') + '-template';
                const sectionClass = sectionName.toLowerCase().replace(/\s+/g, '-') + '-card';
                templates[sectionName] = generateSectionTemplate(sectionData, templateId, sectionClass, sectionName);
            });
            return templates;
        }

        function generateSectionTemplate(sectionData, templateId, cardClass, sectionName) {
            const fields = Object.keys(sectionData);
            let templateHTML = `<template id="${templateId}">
            <div class="${cardClass}">
                <hr style="margin: 0.5em 0; border: none; border-top: 1px solid #ccc;">

                <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 0.25em;">
                    <div class="section-header" 
                        style="font-size: 1em; font-weight: bold; cursor: pointer;" 
                        onclick="toggleSection(this)">
                        ðŸ”½ ${sectionName}
                    </div>
                    <button class="copy-btn" onclick="copyAllSectionInfo(this)">
                        Copy â¿»
                    </button>
                </div>
                
                <div class="section-content">
        `;
            // Add see Subscription Data button to App section
            //if (sectionName === "App") {
            //    templateHTML += `
            //        <button class="open-url-btn small-button" 
            //            data-gnid-placeholder 
            //            style="background-color: #0d6efd; color: white; margin-left: 0em;"
            //            onclick="seeSubscriptionData(this)">
            //            See Subscription Data
            //        </button>
            //    `;
            //}

            // Generate field HTML for each key in the section data
            fields.forEach(fieldKey => {
                templateHTML += `            <div class="field">
                    <div class="field-content">
                        <span class="label">${fieldKey}:</span>
                        <span class="value" data-field="${fieldKey}">-</span>
                    </div>
                </div>
        `;
            }); // <button class="copy-btn" onclick="copyToClipboard(this, '${fieldKey}')">Copy</button>

            templateHTML += `        </div> <!-- End of section-content -->
            </div>
        </template>`;
            return {
                html: templateHTML,
                templateId: templateId,
                cardClass: cardClass,
                sectionName: sectionName
            };
        }


        // render all the templates based on the nested Data
        function renderTemplatesToDOM(templates, containerId, sampleData) {
            const container = document.getElementById(containerId);
            if (!container) {
                console.error(`Container with ID "${containerId}" not found.`);
                return;
            }
            container.innerHTML = ''; // Clear existing content
            Object.values(templates).forEach(templateData => {
                // Inject the <template> HTML into the document (if not already present)
                const tempWrapper = document.createElement('div');
                tempWrapper.innerHTML = templateData.html.trim();
                const templateElement = tempWrapper.firstElementChild;
                // Append the <template> to the body or a central location
                document.body.appendChild(templateElement);
                // Use the template to clone its contents and insert it into the container
                const content = templateElement.content.cloneNode(true);
                // Fill in the template with dictionary values BEFORE appending to container
                // gets the correct dictionary to clone values from e.g. Device Info
                const sectionName = templateData.sectionName;
                const currentSection = sampleData[sectionName];
                if (currentSection) {
                    Object.keys(currentSection).forEach(key => { // e.g. Support ID
                        const element = content.querySelector(`[data-field="${key}"]`); // Use 'content' not 'clone'
                        if (element) {
                            const value = currentSection[key];

                            // If the key is a URL field, create a hyperlink
                            if (key === "Goodnotes ID") {
                                const link = document.createElement("a");
                                link.href = `https://isi.csan.goodnotes.com/admin/customer-timeline/${value}`;//value;
                                link.textContent = value;
                                link.target = "_blank"; // Optional: open in new tab
                                element.innerHTML = ""; // Clear previous content
                                element.appendChild(link);
                            } else if (key === "Support ID") {
                                const link = document.createElement("a");
                                link.href = `https://app.bugsnag.com/goodnotes/goodnotes/errors/?filters[event.unhandled]=true&filters[event.since]=30d&filters[app.release_stage]=production&filters[metaData.GNApp.GNCrashReportUserID]=${value}&sort=events&pivot_tab=event`;
                                link.textContent = value;
                                link.target = "_blank"; // Optional: open in new tab
                                element.innerHTML = ""; // Clear previous content
                                element.appendChild(link);
                                
                            } else {
                                element.textContent = value;
                            }
                        }
                    });
                }
                // Send GNID to See Customer Timeline button
                //if (sectionName === "App" && sampleData["User Account"]["Goodnotes ID"]) {
                //    const openButton = content.querySelector('[data-gnid-placeholder]');
                //    if (openButton) {
                //        openButton.setAttribute('data-gnid', sampleData["User Account"]["Goodnotes ID"]);
                //   }
                //}

                // Now append the populated content to the container
                container.appendChild(content);
            });
        }

        

        // Allows you to toggle the section name
        function toggleSection(headerElement) { 
            const card = headerElement.closest('.' + headerElement.parentElement.parentElement.classList[0]);
            const content = card.querySelector('.section-content');
            if (content.style.display === 'none') { // if toggle is closed, open it on click
                content.style.display = '';
            } else {
                content.style.display = 'none'; // if toggle open, close it on click
            }
        }


        /////////////////////////////////////////////////////////////////////////////////

        // Open Customer Timeline
        function seeSubscriptionData(buttonElement) {
            const gnid = buttonElement.getAttribute('data-gnid');
            if (!gnid || gnid === "None") {
                alert("âŒ GNID not found.");
                return;
            }
            const url = `https://isi.csan.goodnotes.com/admin/customer-timeline/${gnid}`;
            window.open(url, '_blank');
        }




        // Copy to clipboard function
        async function copyToClipboard(button, fieldName) {
            try {
                const deviceCard = button.closest('[class$="-card"]');
                const valueElement = deviceCard.querySelector(`[data-field="${fieldName}"]`);
                const textToCopy = valueElement.textContent;
                await navigator.clipboard.writeText(textToCopy);
                // Visual Feedback
                const originalText = button.textContent;
                button.textContent = 'Copied!';
                button.classList.add('copied');
                setTimeout(() => {
                    button.textContent = originalText;
                    button.classList.remove('copied');
                }, 2000);
            } catch (err) {
                console.error('Failed to copy text: ', err);
            }
        }

        // Generic copy all information function
        async function copyAllSectionInfo(button) {
            let allInfo = ''; // Declare outside try block for proper scope
            try {
                // Find the card container - look for any element with class ending in "-card"
                const sectionCard = button.closest('[class$="-card"]');
                if (!sectionCard) {
                    console.error('Could not find section card container');
                    return;
                }
                // Get the section name from the header
                const sectionHeader = sectionCard.querySelector('.section-header');
                const sectionName = sectionHeader ? sectionHeader.textContent.replaceAll(" ","").replace("ðŸ”½",""): 'Section';
                console.log("Section header", sectionName) // logging for debug
                const fields = sectionCard.querySelectorAll('[data-field]');
                allInfo = `${sectionName}`;
                fields.forEach(field => {
                    const fieldName = field.getAttribute('data-field');
                    const fieldValue = field.textContent;
                    // Convert camelCase to Title Case
                    //const label = fieldName.replace(/([A-Z])/g, ' $1').replace(/^./, str => str.toUpperCase());
                    allInfo += `${fieldName}: ${fieldValue}\n`;
                });
                await navigator.clipboard.writeText(allInfo);
                // Visual feedback
                const originalText = button.textContent;
                button.textContent = 'Copied!';
                button.classList.add('copied');
                setTimeout(() => {
                    button.textContent = originalText;
                    button.classList.remove('copied');
                }, 2000);
            } catch (err) {
                console.error('Failed to copy all text: ', err);
            }
        }
       

    </script>
<!-------------------------------------------------------------------------------------------------------->
    <script>
        client.on('app.registered', function () {
        console.log('App registered!');
        document.getElementById('loadZip').addEventListener('click', function () {
        getDiagnosticDataURLs(client)
        .then(urls => {
            console.log('attachment URLs found:', urls);
            if (urls.length > 0) {
                return downloadAndReadDiagnosticData(urls[urls.length - 1]); // open the last zip
            } else {
                return Promise.reject('No URLs found');
            }
        })
        .catch(error => {
            console.error('âŒ Error loading zip:', error);

            // Send error message to iframe
            const errorBox = document.getElementById('error-box');
            //if (errorBox) {
            errorBox.textContent = 'ðŸš¨ No diagnostic data detected.';
            errorBox.style.display = 'block';
            //}

        })
        .then(result => {
            return parseDiagnosticData(result, targetFiles, client);
        })
        .then(finalData => {
            const templatesDict = generateNestedHTMLTemplates(finalData);
            renderTemplatesToDOM(templatesDict, 'template-container', finalData);
            
        })
        .catch(err => {
            console.error('Error parsing comments:', err);
        });
        })})

        function getDiagnosticDataURLs(client) {
            return client.get('ticket.comments').then(function (data) {
                const urls = [];
                console.log(data['ticket.comments'].length,"comments found");
                for (const comment of data['ticket.comments']) {
                    const attachments = comment['nonImageAttachments'] || [];
                    for (const attachment of attachments) {
                        console.log('Found attachment:', attachment.filename, attachment.contentType);
                        if (
                        attachment.contentType === 'application/zip' ||
                        attachment.filename.toLowerCase().endsWith('.zip')
                        ) {
                        urls.push(attachment.contentUrl);
                        }
                    }
                }
                return urls;
            });
        }

        function downloadBinary(url) {
            console.log("Url received before download", url); // WORKS (downloads in browser)
            return new Promise((resolve, reject) => {
            const req = new XMLHttpRequest();
            req.open('GET', url, true);
            req.responseType = "arraybuffer";
            req.onload = function () {
                resolve(new Blob([req.response]));
                console.log("Loaded blob!");
            };
            req.onerror = function (error) {
                reject(error);
                //console.log("Error loading blob");
            };
            req.send(null);
            });
        }

        function getZipData(blob) {
            return JSZip.loadAsync(blob).then(zip => {
                const result = {}; // dict to be returned
                console.log("Zip", zip);
                const filePromises = [];

                const firstFile = Object.entries(zip.files)[0][0]; // to get ZIP file name e.g. "diagnostic_data_2025-10-23/"
                console.log("First file", firstFile);
                const extension = firstFile.replace(firstFile.substring(firstFile.lastIndexOf("/")+1),"");
                console.log(extension);
                for (const [fileName, section] of Object.entries(targetFiles)) {
                    var file = zip.file(extension + fileName); // match file name
                    //console.log("File name string!!", fileName)
                    if (file) {
                        const promise = file.async("text").then(content => {
                            result[fileName] = content;
                        });
                        filePromises.push(promise);
                    }
                }
                return Promise.all(filePromises).then(() => result);
            });
        }

        function downloadAndReadDiagnosticData(url) {
            // download ZIP as blob
            return downloadBinary(url).then(blob => {
            // Get dict of contents of .txt and .json files
            return getZipData(blob).then(result => {
                console.log("Desired Zip data:", result);
                return result;
            });
            });
        }
        
        const targetFiles = { // change to a dict so I can map display names to file names
            "logs-isi.txt": "Logs ISI",
            "logs.txt": "Logs",
            "device_information.txt": "Device",
            "settings.json": "Settings",
            "paywall_diagnostics.txt": "Library",
            //"writing_aids_info.txt": "Writing Aids",
            "app_store_receipt": "Subscriptions"
        }

        async function parseDiagnosticData(data, targetFiles, client) {
            const dataDict = {}; // Initialize empty dict
            //try {
            //    const response = await client.get('ticket.comments');
            //    const comments = response['ticket.comments'];
            //    for (const comment of comments) {
            //        if (comment.author?.alias) {
            //            continue; // Skip GoodNotes support comments
            //        }
            //        const authorEmail = comment.author.email || "Unknown";
            //        const authorName = comment.author.name || "Unknown";
            //        //dataDict["App"] = {"Email": authorEmail}    
            //    }
            //} catch (error) {
            //    console.error("Error fetching ticket comments:", error);
            //}
            dataDict["App"] = {};
            dataDict["App"]["Goodnotes ID"] = "";
            dataDict["App"]["Membership plan"] = "";
            dataDict["App"]["GN5 User"] = "";
            dataDict["Auto Backup"] = {};
            dataDict["Cloud Sync"] ={};
            
            
         
            // Now process the diagnostic data files
            Object.entries(data).forEach(([filename, content]) => {
                const fileNameString = String(filename);
                console.log("Filename:", fileNameString, typeof fileNameString);

                if (fileNameString.endsWith(".json")) { // for settings.json
                    console.log("JSON file");
                    readSettingsFile(fileNameString, content, dataDict);
                } else if (fileNameString.includes("logs")) { // for logs.txt
                    console.log("Getting logs");
                    getLastBackupTime(content, dataDict);
                    updateLastSyncTime(content, dataDict);
                    accountUsesGNC(content, dataDict);
                    getGNID(content,dataDict);
                } else if (fileNameString.endsWith(".txt")) { // for other .txt files
                    console.log("Text file");
                    readTXTFile(fileNameString, content, dataDict, targetFiles);
                } else if (fileNameString.includes("app_store_receipt")){
                    //console.log("App store receipt", content)
                    readAppStoreReceipt(fileNameString, content, dataDict);
                }
            }); 

            client.metadata().then(meta => { // get other gnids from isi api
                //const apiKey = meta.settings.api_key;
                //const identifier = dataDict["App"]["Goodnotes ID"]; // get gnid
                //const identifier = "tony@goodnotesapp.com"
                //const identifier = "xing@goodnotesapp.com";
                const identifier = "06d09514-804a-4533-a931-04065c3d3db2"
                console.log("Identifier", identifier);
                //fetchCustomerData(client,identifier);//, apiKey);
            });
            console.log("Data dict:", dataDict);
            return dataDict;
        }

        function fetchCustomerData2(identifier, apiKey) {
            //const url = `https://isi.csan.goodnotesbeta.com/nest/api/dataConsolidation/zendesk/byAnyIdentifier/${identifier}`;
            
            fetch(url, {
                headers: {
                'Authorization': `users api-key ${apiKey}`
                }
            })
            .then(res => res.json())
            .then(data => {
                console.log('âœ… API response:', data);
                // TODO: display on my iframe
            })
            .catch(err => console.error("âŒ Fetch error:", err));
        }

        function fetchCustomerData3(identifier){ //, apiKey){ // get isi data gnid
            try {const options = {
                //url: `https://isi.csan.goodnotesbeta.com/nest/api/dataConsolidation/zendesk/byAnyIdentifier/${identifier}`,
                url: `https://isi.csan.goodnotesbeta.com/nest/api/dataConsolidation/zendesk/byAnyIdentifier/06d09514-804a-4533-a931-04065c3d3db2`,
                method: "GET", //type: "GET",
                headers: {
                    Authorization: `Basic ${client._metadata.apiToken}`, //"Basic {{setting.apiToken}}",
                },
                accepts: "application/json",
                secure: true,
            };

            client.request(options)
            .then((response) => {
                console.log("âœ… API response:", response);
            })
            .catch((error) => {
                console.error("âŒ Request failed:", error);
            });

            } catch (error) {
                console.error("Error accessing API:", error);
            }
        }

        function fetchCustomerData(client,identifier) {
            if (!identifier || typeof identifier !== "string") {
                console.error("âŒ Invalid identifier:", identifier);
                return;
            }

            const encodedIdentifier = encodeURIComponent(identifier); 
            console.log("ðŸ“¦ Identifier (encoded):", encodedIdentifier);

            client.metadata().then((metadata) => {
                const apiToken = metadata.settings.apiToken;
                const authHeader = `users api-key ${apiToken}`;

                //const url = `https://isi.csan.goodnotesbeta.com/nest/api/dataConsolidation/zendesk/byAnyIdentifier/${encodedIdentifier}`;
                const url = `https://isi.csan.goodnotesbeta.com/nest/api/dataConsolidation/zendesk/byAnyIdentifier/06d09514-804a-4533-a931-04065c3d3db2`;

                const options = {
                url,
                method: "GET",
                headers: {
                    Authorization: authHeader,
                    Accept: "application/json",
                    //"x-app-version": "6.5.0",
                    //"x-app-type": "web",
                    //"x-app-name": "goodnotes",
                    //"x-product-type": "goodnotes_for_ios"
                },
                secure: true,
                };

                console.log("ðŸ” Sending request to:", url);
                console.log("ðŸ” Headers:", options.headers);

                client.request(options)
                .then((response) => {
                    console.log("âœ… API response:", response);
                })
                .catch((error) => {
                    console.error("âŒ API error:", error);
                    if (error.responseJSON) {
                    console.error("ðŸ“© Error detail:", JSON.stringify(error.responseJSON, null, 2));
                    } else {
                    console.error("ðŸ“© Raw responseText:", error.responseText);
                    }
                });
            });
        }

        

        function getTargetInfo(sectionName){ // using the section, return a list of targetInfo
            if (sectionName === "Device"){
                return ["App version", "Platform", "Device model","OS","System language", "Support ID","Timezone"] //,"Device ID", "SQLite"]
            } else if (sectionName === "Settings"){
                return ["goodNotesEmailAddress"]
            } else if (sectionName === "Library"){
                return ["Used notebooks", "Raw library count", "Shared count", "Trash count"] // "Is free user",
            } else if (sectionName === "Writing Aids"){
                return ["Spellcheck algorithm version","HWR InHouse recognition model version","HWR CJK model version","HWR segmentation model version","HWR Math recognition model version"]
            }
        }

        function readTXTFile(fileNameString, content, dataDict, targetFiles){
            // get section name
            const sectionName = targetFiles[fileNameString]; // get the section name based on the file name key
            dataDict[sectionName] = {};
            
            const targetInfo = getTargetInfo(sectionName);

            const lines = content.split('\n');
            for (const line of lines) { // loop through each line in .txt
                const [rawKey, ...rest] = line.split(':'); // get key and value (either side of ":")
                if (!rawKey || rest.length === 0) continue; // Skip if no key or value
                const key = rawKey.trim(); // get rid of white space
                let value = rest.join(':').trim();
                if (!key) continue; // Skip empty keys
                if (!targetInfo.includes(key)) continue; // Skip if info in not in targetInfo
                // Check for null/invalid values
                if (
                    value.toLowerCase() === "null" ||
                    value.toLowerCase() === "undefined" ||
                    value === ""
                ) {
                    value = "None";
                    console.warn(`âš ï¸ Setting invalid value for key "${key}" to "None"`);
                }
                // Populate the dictionary directly with the original key and value
                if (key === "App version"){
                    dataDict["App"][key] = value;
                } else if (key === "Support ID"){
                    dataDict["App"][key] = value;
                } else {
                    dataDict[sectionName][key] = value;
                }
                
            }
            return dataDict;
        }

        function readSettingsFile(fileNameString, content, dataDict) {
            const jsonObj = JSON.parse(content);
            const targetInfoSettingsJSON = {
                //"Settings": {
                //    "goodNotesEmailAddress": "Goodnotes Email Address",
                //    "searchIndexing": "Search indexing enabled"
                //},
                "Cloud Sync": {
                    "iCloudEnabled": "iCloud enabled"
                },
                "Auto Backup": {
                    "isEnabled": "Auto Backup enabled",
                    "lastBackup": "Last Backup",
                    "storage": "Storage",
                    "isWifiOnly": "Wifi only",
                    "destinationFolderName": "Destination folder"
                }
            };
            function extractAllKeys(obj) {
                for (const [key, value] of Object.entries(obj)) {
                    if (value !== null && typeof value === 'object' && !Array.isArray(value)) {
                        extractAllKeys(value); // recurse
                    } else {
                        if (value === null || value === undefined){
                            var processedValue = "None";
                        } else if (value === true){
                            var processedValue = "Yes";
                        } else if (value === false){
                            var processedValue = "No";
                        } else{
                            var processedValue = value;
                        }
                        for (const [section, targetInfo] of Object.entries(targetInfoSettingsJSON)) {
                            if (key in targetInfo) {
                                const label = targetInfo[key];
                                // Ensure the section exists in dataDict
                                if (!(section in dataDict)) {
                                    dataDict[section] = {};
                                }
                                //if (label === "Goodnotes Email Address") {
                                //    dataDict["App"][label] = processedValue;
                                //} else {
                                dataDict[section][label] = processedValue;
                                //}
                            }
                        }
                    }
                }
            }
            extractAllKeys(jsonObj);
            return dataDict;
        }

        function getLastBackupTime(content, dataDict) { // last backup time
            const lines = content.split('\n');
            let lastBackUpTime = null;
            for (const line of lines) {
                if (line.includes("Last backup finished:")) {
                    const match = line.match(/Last backup finished:\s*(.+)/);
                    if (match && match[1]) {
                        lastBackUpTime = match[1].trim(); // Update with each match
                    }
                }
            }
            if (lastBackUpTime){
                dataDict["Auto Backup"]["Last Backup"] = lastBackUpTime;
            } else {
                console.log("âš ï¸ No backup time found in log.")
                dataDict["Auto Backup"]["Last Backup"] = "Never";
            }
            return dataDict;
        }

        function updateLastSyncTime(content, dataDict) {
            const lines = content.split('\n');
            let lastSyncTime = null;
            for (const line of lines) {
                if (line.includes('Synchronization completed')) {
                    const match = line.match(/^(\d{4}\/\d{2}\/\d{2} \d{2}:\d{2})/);
                    if (match && match[1]) {
                        lastSyncTime = match[1];
                    }
                }
            }
            if (lastSyncTime) {
                dataDict["Cloud Sync"]["Last sync"] = lastSyncTime;
            } else {
                dataDict["Cloud Sync"]["Last sync"] = "Never";
                console.log("âš ï¸ No sync time found in log.");
            }
            return dataDict;
        }

        function accountUsesGNC(content, dataDict) {
            try {
                // Initialize the structure if it doesn't exist
                //if (!dataDict["Cloud Sync"]) {
                //    dataDict["Cloud Sync"] = {};
                //}
                
                // Find all occurrences of accountUseGnCloud
                const regex = /accountUseGnCloud:\s*(true|false)/gi;
                const matches = [];
                let match;
                
                while ((match = regex.exec(content)) !== null) {
                    matches.push({
                        value: match[1],//.toLowerCase(),
                        position: match.index
                    });
                }
                
                if (matches.length > 0) {
                    // Get the last occurrence (highest position)
                    const lastMatch = matches[matches.length - 1];
                    const value = lastMatch.value;

                    if (value === true){
                        dataDict["Cloud Sync"]["GN Cloud enabled"] = "Yes";
                    } else {
                        dataDict["Cloud Sync"]["GN Cloud enabled"] = "No";
                    }
                    //dataDict["Cloud Sync"]["GN Cloud enabled"] = value;
                    
                    console.log(`ðŸ“‹ Found ${matches.length} GN Cloud setting(s). Last value: ${value}`);
                } else {
                    dataDict["Cloud Sync"]["GN Cloud enabled"] = "No";
                    console.log("âš ï¸ No GN Cloud setting found in the content.");
                }
                
            } catch (error) {
                console.error("âŒ Error processing GN Cloud setting:", error);
                if (!dataDict["Cloud Sync"]) {
                    dataDict["Cloud Sync"] = {};
                }
                dataDict["Cloud Sync"]["GN Cloud enabled"] = "error";
            }
            
            return dataDict;
        }
        
        function getGNID(content,dataDict){
            const lines = content.split('\n');
            let GNID = null; // Goodnotes ID (for linking to ISI)
            for (const line of lines) {
                if (line.includes('userId')|| line.includes('ISI')) {
                    //const match = line.match(/^(\d{4}\/\d{2}\/\d{2} \d{2}:\d{2})/);
                    const match = line.match(/\b([0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12})\b/i);
                        //GNID = match[1];
                        if (match && match[1]) {
                            const GNID = match[1];
                            console.log("GNID:", GNID)
                            // use value
                            dataDict["App"]["Goodnotes ID"] = GNID || "Unkown";
                        }
                    }
                }   
            return dataDict;
        }

        function subscriptionValid(subEnd){
            const endDate = new Date(subEnd) // turns it into a date obj
            const today = new Date();
            endDate.setHours(0, 0, 0, 0); // ignore the time, just the date
            today.setHours(0, 0, 0, 0);
            console.log("TODAY", today,"END DATE", endDate);
            if (endDate > today -1){ // expiry is after today
                return true;
            } else{
                return false;
            }
        }
        function readAppStoreReceipt(fileNameString, content, dataDict){
            const lines = content.split('\n');
            //console.log(lines);
            const prodIDs = [
                // GN6 one-time unlock
                "com.goodnotes.gn6_one_time_unlock_3999",
                "com.goodnotes.gn6_one_time_unlock_2999",
                "com.goodnotes.gn6_one_time_unlock_3499",
                "com.goodnotes.gn6_one_time_unlock_3749",
                "com.goodnotes.gn6_one_time_unlock",
                // GN5 one-time unlock
                "com.goodnotes.one_time_unlock",
                // Apple-XP subscription
                "com.goodnotes.premium_7dt_1y_999",
                "com.goodnotes.premium_1yf_1y_999",
                "com.goodnotes.premium_1y25off_1y_999",
                "com.goodnotes.premium_7dt_1y_999",
                "com.goodnotes.premium_1y_799",
                "com.goodnotes.premium_1y_699",
                // XP-only subscription
                "com.goodnotes.xp_1y_559",
                "com.goodnotes.xp_7dt_1y_699",
                "com.goodnotes.xp_1y_699",
            ];
            const oneTimeUnlockGN5 = {}; // GN5 one-time purchase
            const oneTimeUnlockGN6 = {}; // GN6 one-time purchase
            const activeSubscriptions = {}; // active subscriptions
            const expiredSubscriptions = {}; // expired subscriptions
            // Initialise values
            dataDict["App"]["Membership plan"] = "";
            dataDict["App"]["GN5 User"] = "Never";
        
            for (const line of lines){      
                for (const prodID of prodIDs){
                    if (line.includes(prodID)){
                        // Find the product ID and nearby data
                        console.log(prodID);
                        const regex = new RegExp(`.{0,150}${prodID}.{0,150}`, 's');
                        const match = line.match(regex);
                        if (match) {
                        const chunk = match[0];
                        // Extract date-only strings (yyyy-mm-dd) from timestamps
                        const dateMatches = [...chunk.matchAll(/\d{4}-\d{2}-\d{2}/g)];
                        console.log(dateMatches);
                        if (dateMatches.length >= 2) {
                            const startDate = dateMatches[0][0];
                            const expiryDate = dateMatches[dateMatches.length - 1][0];
                            console.log("ðŸ“… Start Date:", startDate);
                            console.log("ðŸ“… Expiry Date:", expiryDate);
                            // One time purchase/doesn't expire
                            if (startDate === expiryDate){ 
                                if (prodID.includes("com.goodnotes.one_time_unlock")){ // GN5 
                                    oneTimeUnlockGN5[prodID] = {"Start": startDate};
                                } else { // should only be gn6 one-time-unlock
                                    oneTimeUnlockGN6[prodID] = {"Start": startDate};
                                }
                            } else { // Subscription
                                if (subscriptionValid(expiryDate)){
                                    activeSubscriptions[prodID] = {"Start": startDate, "End": expiryDate};
                                    console.log("Active subscriptions", activeSubscriptions);
                                } else { // prodID+startDate because there are the same 7 day trials added at different times
                                    expiredSubscriptions[prodID+startDate] = {"Start": startDate, "End": expiryDate};
                                } 
                            }
                        } else {
                            console.warn("âŒ Not enough dates found near the product.");
                        }
                        }   
                    }
                }
            }
            // Logging 
            console.log("oneTimeUnlockGN5",oneTimeUnlockGN5);
            console.log("oneTimeUnlockGN6",oneTimeUnlockGN6);
            console.log("activeSubscriptions",activeSubscriptions);
            console.log("expiredSubscriptions",expiredSubscriptions);
            
            // Membership logic
            if (Object.keys(oneTimeUnlockGN5).length===0 && Object.keys(oneTimeUnlockGN6).length===0 && Object.keys(activeSubscriptions).length===0){ 
                // No purchases = Freemium
                console.log("GN6 Free");
                dataDict["App"]["Membership plan"] = "GN6 Free"; 
                dataDict["App"]["GN5 User"] = "Never";
            } else if (Object.keys(oneTimeUnlockGN5).length===1 && Object.keys(oneTimeUnlockGN6).length===0 && Object.keys(activeSubscriptions).length===0){ 
                // GN5 one-time unlock
                console.log("GN5 one-time unlock");
                dataDict["App"]["Membership plan"] = `GN5 (Since ${oneTimeUnlockGN5[Object.keys(oneTimeUnlockGN5)[0]].Start})`;
                dataDict["App"]["GN5 User"] = "Currently";
            } else if (Object.keys(oneTimeUnlockGN6).length>0 && Object.keys(activeSubscriptions).length===0){
                // GN6 one-time unlock
                console.log("GN6 one-time unlock");
                dataDict["App"]["Membership plan"] = `GN6 Apple One-Time Payment (Since ${oneTimeUnlockGN6[Object.keys(oneTimeUnlockGN6)[0]].Start})`;
                if (Object.keys(oneTimeUnlockGN5).length===1){
                    dataDict["App"]["GN5 User"] = "Previously";
                }
            } else if (Object.keys(activeSubscriptions).length>0){ // If there active subscriptions
                // all platforms or xp only
                if (Object.keys(activeSubscriptions).length>1){
                    // multiple active subscriptions 
                    console.log("ðŸš¨ Multiple active subscriptions");
                    dataDict["App"]["Membership plan"] = "ðŸš¨ Multiple active subscriptions";
                } else if (Object.keys(activeSubscriptions)[0].includes("premium")){
                    // All platforms susbscription
                    console.log("GN6 All Platforms Yearly - Expires",activeSubscriptions[Object.keys(activeSubscriptions)[0]].End);
                    dataDict["App"]["Membership plan"] = `GN6 All Platforms Yearly (Expires ${activeSubscriptions[Object.keys(activeSubscriptions)[0]].End})`
                } else if (activeSubscriptions[Object.keys(activeSubscriptions)[0]].includes("xp")){
                    console.log("GN6 XP Only Yearly - Expires",activeSubscriptions[Object.keys(activeSubscriptions)[0]].End);
                    dataDict["App"]["Membership plan"] = `GN6 Android & Windows Yearly (Expires ${activeSubscriptions[Object.keys(activeSubscriptions)[0]].End})`
                }  

                if (Object.keys(oneTimeUnlockGN5).length===1){
                    dataDict["App"]["GN5 User"] = "Previously";
                }
            } else if (Object.keys(oneTimeUnlockGN6).length===0 && Object.keys(activeSubscriptions).length===0 && Object.keys(expiredSubscriptions).length>0){
                // Only have expired subscriptions
                console.log("GN Free");
                dataDict["App"]["Membership plan"] = "GN6 Free"; 
                if (Object.keys(oneTimeUnlockGN5).length===0){
                    dataDict["App"]["GN5 User"] = "Never";
                } else {
                    dataDict["App"]["GN5 User"] = "Currently";
                }
            } else {
                dataDict["App"]["Membership plan"] = "Unknown"; 
            }
        }
    </script>



    
</body>
</html>